Some notes on life.py
Christian Burnham
June 2013

=============================================================
                Random pattern generation
=============================================================
The spec asked for the user to be able to set a random pattern in which N live cells are randomly placed on the board.  However, 
I thought it would be more useful for the user to choose a *density* of live cells.

=============================================================
	Internal representation of patterns
=============================================================
The code uses two methods to represent a pattern.  The first is a list of lists in which live cells are represented by the integer 
1 and dead cells are represented by 0, e.g. the pattern 

- * * * - 
- * - - - 
- - - - -

would be represented by 

board = [[0,1,1,1,0],
         [0,1,0,0,0],
	 [0,0,0,0,0]]

The second way to represent each pattern is through a tuple.  First, number the cells as follows:

- - - - -      	  0  1  2  3  4   
- - - - -    ->   5  6  7  8  9 
- - - - -        10 11 12 13 14 

Then make a list of the cells which have live cells, e.g. 

- * * * - 
- * - - - 
- - - - -

is represented as 

tuple = (1,2,3,6)

The conversion between representations is contained in methods:

Life.getTupleFromPattern() and Life.setPatternFromTuple(tuple):

=============================================================
	        Boundary conditions
=============================================================
This code uses periodic (toroidal) boundary conditions when running the game, i.e. the pattern wraps horizontally and vertically.  
This can be seen in the method Life.update(), which implements the GOL rule-set.  


=============================================================
                Still life enumeration.
=============================================================

The method Controller.findStillLife() uses the following basic algorithm:

i) Enumerate all possible patterns containing N live cells.

(To avoid boundary effects, the method actually enumerates only patterns where all the cells are contained within a 1 
cell 'safety-margin' running around the perimeter of the board.)

ii) For each candidate pattern, find the pattern on the next generation using the GOL rule-set.

iii) Check to see if this new pattern is identical to the original.  If it is, then this a still-life pattern has been 
found and should be printed out to the terminal.


One problem with the above algorithm is that it enumerates functionally identical patterns, related by rotational and translational 
symmetry.  

The first symmetry to consider is that of the board itself.  

---------------------------
Symmetries of the rectangle
---------------------------

Consider a rectangular board, which has 2 lines of symmetry:  Rotation of Pi about a horizontal bisector and rotation of Pi about a vertical bisector.

None of these symmetries fundamentally changes the pattern.  For instance, the following 4 patterns are the same and need only be 
counted once.

- - - - - - -            - - - - - - - 
- * * * - - - 		 - - - * * * - 
- * - - - - - 		 - - - - - * - 
- - - - - - - 		 - - - - - - - 
- - - - - - - 		 - - - - - - - 

- - - - - - - 		 - - - - - - - 
- - - - - - - 		 - - - - - - - 
- * - - - - - 		 - - - - - * - 
- * * * - - - 		 - - - * * * - 
- - - - - - -            - - - - - - - 

In order to do this, the following algorithm was used:

i) From each candidate pattern, reflect it about a) the horizontal, b) the vertical and c) the horizontal + the vertical 
in order to produce the other three reflections.

ii) Calculate a 1D tuple representation of each of the four patterns, where the following numbering scheme is used

-  -  -  -  -  - -
-  0  1  2  3  4 -
-  5  6  7  8  9 -
- 10 11 12 13 14 -
-  -  -  -  -  - -
(note the 1 cell 'safety-margin')

so, for example, the above four patterns would be labeled 

p1 = (0,1,2,5)
p2 = (2,3,4,9)
p3 = (5,10,11,12)
p4 = (9,12,13,14)

iii) Only evaluate the pattern if p1 <= p2 and p1 <= p3 and p1 <= p4, thus ensuring that only one of the four patterns is evaluated.

--------------------------
Symmetries of the square
--------------------------
Square boards have 4 additional symmetries, bringing the total to 8.  

For instance, the following 8 patterns are equivalent under rotations:

- - - - -    - - - - - 
- * * * -    - * * * - 
- * - - -    - - - * - 
- - - - -    - - - - - 
- - - - -    - - - - - 

- - - - -    - - - - - 
- - - - -    - - - - - 
- * - - -    - - - * - 
- * * * -    - * * * - 
- - - - -    - - - - - 

- - - - -    - - - - - 
- * * - -    - - * * - 
- * - - -    - - - * - 
- * - - -    - - - * - 
- - - - -    - - - - - 

- - - - -    - - - - - 
- * - - -    - - - * - 
- * - - -    - - - * - 
- * * - -    - - * * - 
- - - - -    - - - - - 

For square boards, this code will evaluate only one of each of the eight rotations.

----------------------
Translational symmetry
----------------------

Patterns are considered unchanged with respect to translation.  For instance, the following patterns are functionally identical, related by a 
translation:

- - - - - - -     - - - - - - -    - - - - - - -
- * * * - - -	  - - - - - - -	   - - - - - - -
- * - - - - -	  - - * * * - -	   - * * * - - -
- - - - - - -	  - - * - - - -	   - * - - - - -
- - - - - - -	  - - - - - - -	   - - - - - - -

It's simple to remove all such duplicates.  To do so have the algorithm only count patterns which contain a live cell in both the 
left-most column and the top-most row.

-----------------
Note the above removal of board reflection symmetries and translations isn't quite enough to remove all duplicates.  It still 
leaves reflections along axes which are not symmetry axes of the board.  Even so, these improvements are good enough to speed up 
the calculation by more than 4X for rectangular boards and 6X for square boards.


